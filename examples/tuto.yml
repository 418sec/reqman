
##############################################################################
##
## this is a tutorial : if you read step by step this guide ; you will
## masterize how to create a test file (*.yml or .rml)
##
##############################################################################



#--------------------------------------------
# the simplest call !
# (you won't need a reqman.conf (because the uri is absolute))
- GET: https://google.com

#--------------------------------------------
# but it can be very handy, to have one, with a declared "root" var (ex: root: https://github.com)
# so all requests can have a common path
- GET: /      # <-- it does a HTTP GET at the root of the root var

#--------------------------------------------
# obviously, you can use the others HTTP VERBS (always in uppercase)
- POST: /
- PUT: /
- DELETE: /
- PATCH: /
- OPTIONS: /
- HEAD: /
- TRACE: /
- CONNECT: /

#--------------------------------------------
# Thus, you can use send your headers as :
- GET: /
  headers:
    Authorization: Bear me
    user-agent:    Just Me


#--------------------------------------------
# And you can use set your body :
- POST: /
  headers:
    user-agent:   Hello, it's me
  body:           For sure ; It's me ;-)

#--------------------------------------------
# You can send json, like that :
- POST: /
  headers:
    Content-Type: application/json        # best practice, but not needed
  body:           {"name":"jo","age":42}  # json is a subclass of the yaml syntax !

#--------------------------------------------
# But reqman, let you write as yaml too, it's more readable :
- POST: /
  headers:
    Content-Type: application/json        # best practice, but not needed
  body:
    name:         jo                      # \_ It's exactlly like previous request ^^
    age:          42                      # /  (more readable)

#--------------------------------------------
# You can override vars, with params (here, you won't need a reqman.conf)
- GET: /
  params:
    root: http://google.com   # thus, root will be overriden for this request

#--------------------------------------------
# You can declare vars, with params
- POST: /
  body: <<message>>
  params:
    message: I'm the message


#TODO: talk about special params 'timeout' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#TODO: talk about special params 'timeout' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#TODO: talk about special params 'timeout' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#--------------------------------------------
# if you want to declare multiline text in your message
- POST: /
  body: <<message>>
  params:
    message: |            # <-- use this yaml syntax, use "|" will create multiple lines
      I'm the line 1
      I'm the line 2
      I'm the line 3

#--------------------------------------------
# And your var can be transformed by a (python) method like that:
- POST: /
  body: <<message|encode>>
  params:
    message: I'm the message
    encode: |
      import base64
      return str(base64.b64encode(bytes(x, 'utf-8')),"utf8")    # 'x' is the input (here; content of message ;-)

#--------------------------------------------
# IMPORTANT NOTE :
# - you can make a global method, by declaring it in the reqman.conf, so you can use
#   it in all your tests !

#--------------------------------------------
# alternativly you can call a method without input, like that :
- POST: /
  body: <<|now>>
  params:
    now: return datetime.datetime.now().strftime("%Y-%m-%d_%H:%M")

#--------------------------------------------
# But params are usefull for procedures, to avoid repeating yourself (DRY !)

- my_procedure:   # this is a declaration !
    - GET: /
    - POST: /
      body: <<message>>
    - GET: /

- call: my_procedure  # here is the call
  params:
    message: Hello1

- call: my_procedure  # here is a second call
  params:
    message: Hello2

#--------------------------------------------
# procedures and params can serve to create context too
# (here, you won't need a reqman.conf)
- my_context:   # this is a declaration !
    - GET: /

- call: my_context  # here is the call, with overriding root
  params:
    root: http://google.com

#--------------------------------------------
# of course, you can create procedures in procedures, and so on

- proc1:                   # this is a declaration !
    - proc2:               # this is a sub declaration !
      - GET: /nib
    - call: proc2
    - call: proc2

- call: proc1  # this will produce 2 gets !

#--------------------------------------------
# AFAIK, it could be written like this

- proc1:                   # this is a declaration !
    - proc2:               # this is a sub declaration !
      - GET: /nib
    - call:               # Call can be a list of procedures to call !!!
      - proc2
      - proc2

- call: proc1  # this will produce 2 gets !

#--------------------------------------------
# or better, it could be written like this

- proc1:                   # this is a declaration !
    - proc2:               # this is a sub declaration !
      - GET: /nib
    - call: <<|caller>>    # Call can be a list of procedures to call !!!

- call: proc1  # this will produce 2 gets !
  params:
    caller: return ["proc2","proc2"]

#--------------------------------------------
# or better (developper way), it could be written like this

- proc1:                   # this is a declaration !
    - proc2:               # this is a sub declaration !
      - GET: /nib
    - call: <<2|caller>>    # Call can be a list of procedures to call !!!

- call: proc1  # this will produce 2 gets !
  params:
    caller: return x * ["proc2"]

#--------------------------------------------
# IMPORTANT NOTE : 
#  - You can make a global procedure, if you declare it in the reqman.conf
#  - There are special procedures whose are called at the beginning (name it 'BEGIN'),
#    and at the ending (name it 'END'), of the tests !

#--------------------------------------------
# But requests without tests are useless
# (and, it's the main job of reqman)
- GET: /
  tests:                  # "tests" is a list of tests !
    - status: 200                 # "status" is a special key, the http status is 200 OK
    - content-type: text/html     # others are headers : the response "content-type" is text/html
    - content-type: html          # the response content type is html, for sure
    - content-type: text          # so it's text, for sure
    - content:  <body>            # "content" is a special key : assert that "<body>" is in the content
    - content:  </body>           # assert that "</body>" is in the content

#--------------------------------------------
# tests value can be a yaml list
- GET: /
  tests:                  
    - status:                     # so the http status can be
              - 200               # 200        \__ the test is valid if one is valid
              - 302               # or 302     /

#--------------------------------------------
# and if your respone is pure json, you can test its content using prefix "json."
- GET: /
  tests:                          
    - status:       200           
    - json.result:  ok            # assuming response = {"result":"ok"}

#--------------------------------------------
# obviously, you can use comparator using syntax: ". op value" (op in =,!=,<,>,<=,>=)
# (but not recommended : stay simple and stupid ...)
- GET: /
  tests:                          
    - status:       . < 400           
    - status:       . >= 200           
    - json.result:  . != ko            # assert response = {"result":"ok"}

#--------------------------------------------
# and you can index arrays in json's response
- GET: /
  tests:                          
    - status:         200           
    - json.result.1:  2           # assert response = {"result":[1,2,3]}
#--------------------------------------------
# and you can guess size array in json's response, with special attribute ".size"
- GET: /
  tests:                          
    - status:            200           
    - json.result.size:  3        # assert response = {"result":[1,2,3]}

#--------------
# should continue


# TODO: more here !



