{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Reqman Reqman is a postman killer. It deserves the same goal, but without GUI : you can test yours http things with commandline under any operating system. All configurations is done via simple yaml files, editable with any text editors. Results are displayed in console and in an html output. It's scriptable, and can be used as a daemon/cron task to automate your tests. Reqman shines with: Tests http apis / website Non regression tests Automatic tests Batch http process TDD of apis Reqman 's history : postman is cool, but is not adapted to non-tech people, to implement \"tests\" (need JS knowledge), when things going harder. Btw, it (the free version) is a mess when you want to share your tests in a source control system. And the lack of a headless mode (#), for scripting is problematic. So there were room for reqman . With reqman you can put your complex things in reqman.conf, and let your tests be simple, and easily maintenable by non-tech people. (#: nowadays, it exists, but it's complex to setup) Reqman 's name is a joke, a contraction of \"request\" and \"man\" ... and it can do a lot more than just POST requests ;-) ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE !","title":"Introduction"},{"location":"#reqman","text":"Reqman is a postman killer. It deserves the same goal, but without GUI : you can test yours http things with commandline under any operating system. All configurations is done via simple yaml files, editable with any text editors. Results are displayed in console and in an html output. It's scriptable, and can be used as a daemon/cron task to automate your tests. Reqman shines with: Tests http apis / website Non regression tests Automatic tests Batch http process TDD of apis Reqman 's history : postman is cool, but is not adapted to non-tech people, to implement \"tests\" (need JS knowledge), when things going harder. Btw, it (the free version) is a mess when you want to share your tests in a source control system. And the lack of a headless mode (#), for scripting is problematic. So there were room for reqman . With reqman you can put your complex things in reqman.conf, and let your tests be simple, and easily maintenable by non-tech people. (#: nowadays, it exists, but it's complex to setup) Reqman 's name is a joke, a contraction of \"request\" and \"man\" ... and it can do a lot more than just POST requests ;-) ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE ! ! A LOT OF DOCS NEED TO BE WRITTEN HERE !","title":"Reqman"},{"location":"command/","text":"The command line You can pass an many yaml's test files or folders as you want. Reqman will compute a list of tests, and order them according names. So it's a good practice, to prefix file names with numbers. Reqman will ignore files/folders starting with a \".\" or \"_\". And it will run the tests against the first reqman.conf found in the common path, if it exists. If reqman.conf contains switchs , you'll be able to add switchs in your command line. USAGE TEST : reqman [--option] [-switch] <folder|file>... USAGE CREATE : reqman new <url> Version 2.1.0.2 Test a http service with pre-made scenarios, whose are simple yaml files (More info on https://github.com/manatlan/reqman) <folder|file> : yml scenario or folder of yml scenario (as many as you want) [option] --k : Limit standard output to failed tests (ko only) --p : Paralleliz file tests (display only ko tests) --o:name : Set a name for the html output file --o : No html output file, but full console --b : Open html output in browser if generated --s : Save RMR file --r : Replay the given RMR file in dual mode [switch] : pre-made 'switch' defined in a reqman.conf Reqman's options p: paralleliz Will run a \"thread\" by test's file. It's a lot speeder ;-) b: browser Will open reqman.html file in the default browser, after tests. ... will continue to explain new reqman2 features ... ... will continue to explain new reqman2 features ... ... will continue to explain new reqman2 features ... ... will continue to explain new reqman2 features ... ... will continue to explain new reqman2 features ... ... will continue to explain new reqman2 features ... Start a new project There is a special command to start a new project from scratch : $ reqman new https://www.example.com/myapi/v1/test It will create, in the current folder, a (very) basic reqman.conf and a test file against this url And you can run test immediatly : $ reqman . Shebang mode It's my most loved feature, over reqman1 ;-) Very useful in a text editor : just configure your editor to run the edited yaml file against reqman executable. And if you run a single file, without any parameters. Reqman will look at the shebang, and use the parameters. #!/usr/local/bin/reqman --b -prod - GET : /<<path>> params : path : \"hello\" or #! --b -prod - GET : /<<path>> params : path : \"hello\" Will run the file, with prod switch, and open the html output in the default browser ... (if the file is runned with others files or with options/switch ... reqman will use options/switchs from commandline) Very handy, to avoid to go in console while coding your test ;-)","title":"Command Line"},{"location":"command/#the-command-line","text":"You can pass an many yaml's test files or folders as you want. Reqman will compute a list of tests, and order them according names. So it's a good practice, to prefix file names with numbers. Reqman will ignore files/folders starting with a \".\" or \"_\". And it will run the tests against the first reqman.conf found in the common path, if it exists. If reqman.conf contains switchs , you'll be able to add switchs in your command line. USAGE TEST : reqman [--option] [-switch] <folder|file>... USAGE CREATE : reqman new <url> Version 2.1.0.2 Test a http service with pre-made scenarios, whose are simple yaml files (More info on https://github.com/manatlan/reqman) <folder|file> : yml scenario or folder of yml scenario (as many as you want) [option] --k : Limit standard output to failed tests (ko only) --p : Paralleliz file tests (display only ko tests) --o:name : Set a name for the html output file --o : No html output file, but full console --b : Open html output in browser if generated --s : Save RMR file --r : Replay the given RMR file in dual mode [switch] : pre-made 'switch' defined in a reqman.conf","title":"The command line"},{"location":"command/#reqmans-options","text":"","title":"Reqman's options"},{"location":"command/#p-paralleliz","text":"Will run a \"thread\" by test's file. It's a lot speeder ;-)","title":"p: paralleliz"},{"location":"command/#b-browser","text":"Will open reqman.html file in the default browser, after tests. ... will continue to explain new reqman2 features ... ... will continue to explain new reqman2 features ... ... will continue to explain new reqman2 features ... ... will continue to explain new reqman2 features ... ... will continue to explain new reqman2 features ... ... will continue to explain new reqman2 features ...","title":"b: browser"},{"location":"command/#start-a-new-project","text":"There is a special command to start a new project from scratch : $ reqman new https://www.example.com/myapi/v1/test It will create, in the current folder, a (very) basic reqman.conf and a test file against this url And you can run test immediatly : $ reqman .","title":"Start a new project"},{"location":"command/#shebang-mode","text":"It's my most loved feature, over reqman1 ;-) Very useful in a text editor : just configure your editor to run the edited yaml file against reqman executable. And if you run a single file, without any parameters. Reqman will look at the shebang, and use the parameters. #!/usr/local/bin/reqman --b -prod - GET : /<<path>> params : path : \"hello\" or #! --b -prod - GET : /<<path>> params : path : \"hello\" Will run the file, with prod switch, and open the html output in the default browser ... (if the file is runned with others files or with options/switch ... reqman will use options/switchs from commandline) Very handy, to avoid to go in console while coding your test ;-)","title":"Shebang mode"},{"location":"conf/","text":"Using a reqman.conf It can be very useful to share common things in a single place : the reqman.conf is here for that ! Basically, it's a yaml file, which is a dictionnary of key:value. It is useful : to define some globals parameters (root, timeout, headers, ...) to declare some switchs for command line. to share some global procedures between yaml's files. to share some global python params/methods between yaml's files. Define some globals parameters Here are some special parameters, but you can create as many global parameters as you want ;-) \"root\" It's the root path, which is used as prefix when a request use an absolute path root : https://example.com tip: this var can be overriden in a \"params\"/\"foreach\" statement. \"timeout\" It's the max time in ms to wait the response timeout : 100 #100ms max tip: this var can be overriden in a \"params\"/\"foreach\" statement. \"headers\" Global headers for all tests headers : content-type : application/json Declare switchs for command line \"switchs\" Switchs are a reqman's feature, to let you override default param with command line switchs. Here is a simple reqman.conf: root : https://example.com switchs : goog : root : https://google.com if you run : $ reqman test.yml it will use https://example.com as root var. if you run : $ reqman test.yml -goog it will use https://google.com as root var. You can combine as many switchs as you want ... BTW, you can add a 'doc' statement, which will appear in command line usage , like this: root : https://example.com switchs : goog : doc : \"to test google ;-)\" root : https://google.com Declare procedures As you can declare a procedure in a yaml's test file, you can declare it in the reqman.conf. So every test's files can use it. But there are two special procedures: BEGIN & END \"BEGIN\" procedure It's a special procedure, which can be declared in reqman.conf only, and is called at the beginning of all tests. It can be useful to obtain an oauth2 token bearer, initiate some things, ... \"END\" procedure It's a special procedure, which can be declared in reqman.conf only, and is called at the end of all tests. It can be useful to clear some things after all tests, ...","title":"Using a global conf"},{"location":"conf/#using-a-reqmanconf","text":"It can be very useful to share common things in a single place : the reqman.conf is here for that ! Basically, it's a yaml file, which is a dictionnary of key:value. It is useful : to define some globals parameters (root, timeout, headers, ...) to declare some switchs for command line. to share some global procedures between yaml's files. to share some global python params/methods between yaml's files.","title":"Using a reqman.conf"},{"location":"conf/#define-some-globals-parameters","text":"Here are some special parameters, but you can create as many global parameters as you want ;-)","title":"Define some globals parameters"},{"location":"conf/#root","text":"It's the root path, which is used as prefix when a request use an absolute path root : https://example.com tip: this var can be overriden in a \"params\"/\"foreach\" statement.","title":"\"root\""},{"location":"conf/#timeout","text":"It's the max time in ms to wait the response timeout : 100 #100ms max tip: this var can be overriden in a \"params\"/\"foreach\" statement.","title":"\"timeout\""},{"location":"conf/#headers","text":"Global headers for all tests headers : content-type : application/json","title":"\"headers\""},{"location":"conf/#declare-switchs-for-command-line","text":"","title":"Declare switchs for command line"},{"location":"conf/#switchs","text":"Switchs are a reqman's feature, to let you override default param with command line switchs. Here is a simple reqman.conf: root : https://example.com switchs : goog : root : https://google.com if you run : $ reqman test.yml it will use https://example.com as root var. if you run : $ reqman test.yml -goog it will use https://google.com as root var. You can combine as many switchs as you want ... BTW, you can add a 'doc' statement, which will appear in command line usage , like this: root : https://example.com switchs : goog : doc : \"to test google ;-)\" root : https://google.com","title":"\"switchs\""},{"location":"conf/#declare-procedures","text":"As you can declare a procedure in a yaml's test file, you can declare it in the reqman.conf. So every test's files can use it. But there are two special procedures: BEGIN & END","title":"Declare procedures"},{"location":"conf/#begin-procedure","text":"It's a special procedure, which can be declared in reqman.conf only, and is called at the beginning of all tests. It can be useful to obtain an oauth2 token bearer, initiate some things, ...","title":"\"BEGIN\" procedure"},{"location":"conf/#end-procedure","text":"It's a special procedure, which can be declared in reqman.conf only, and is called at the end of all tests. It can be useful to clear some things after all tests, ...","title":"\"END\" procedure"},{"location":"example/","text":"A classic example Here is a classic config, with oauth2 authentification, and two mode switchs. When reqman is executed without switchs ( reqman test.yml ): It will target the server on localhost. It will use a default access_token, for development When reqman is executed with a switch 'prod' ( reqman test.yml -prod ): It will target the server on example.com (root overriden) It will try to obtain a access_token on authorization server (via BEGIN procedure) A reqman.conf root : http://localhost:8080 token : # jwt token for local dev token_type : Bearer access_token : eyJhbGciOiJIUzI1NiIsInR6cCI6IkpXVCJ9.eyJzdWIiOiIxMzUwNjg4MjciLCJjZGV0YWIiOiIxNjI3NSIsImFwcGlkIjoicG9zdGVfbG9jYWwifQ.XMPNGpB5TUbmm08h2s79KYol32MQaRT_CvhAoTBBBnI headers : Content-Type : application/json; charset=utf-8 x-hello : it's me Authorization : <<token.token_type>> <<token.access_token>> switchs : prod : doc : Test in production root : https://example.com BEGIN : POST : https://authorization.server.example.com/oauth/token headers : Content-Type : application/x-www-form-urlencoded body : grant_type=client_credentials&client_id=dbfa1d28-c815-4b61-a435-0b2b761d30ab&client_secret=cbe46cde-affb-4324-8f26-f69ace80f1ce tests : - status : 200 save : token And a yml test file - GET : /api/pets/v1/list tests : - status : 200 save : pets : <<json.items>> - GET : /api/pets/v1/info/<<id>> params : id : <<json.items.0.id>>","title":"An example"},{"location":"example/#a-classic-example","text":"Here is a classic config, with oauth2 authentification, and two mode switchs. When reqman is executed without switchs ( reqman test.yml ): It will target the server on localhost. It will use a default access_token, for development When reqman is executed with a switch 'prod' ( reqman test.yml -prod ): It will target the server on example.com (root overriden) It will try to obtain a access_token on authorization server (via BEGIN procedure)","title":"A classic example"},{"location":"example/#a-reqmanconf","text":"root : http://localhost:8080 token : # jwt token for local dev token_type : Bearer access_token : eyJhbGciOiJIUzI1NiIsInR6cCI6IkpXVCJ9.eyJzdWIiOiIxMzUwNjg4MjciLCJjZGV0YWIiOiIxNjI3NSIsImFwcGlkIjoicG9zdGVfbG9jYWwifQ.XMPNGpB5TUbmm08h2s79KYol32MQaRT_CvhAoTBBBnI headers : Content-Type : application/json; charset=utf-8 x-hello : it's me Authorization : <<token.token_type>> <<token.access_token>> switchs : prod : doc : Test in production root : https://example.com BEGIN : POST : https://authorization.server.example.com/oauth/token headers : Content-Type : application/x-www-form-urlencoded body : grant_type=client_credentials&client_id=dbfa1d28-c815-4b61-a435-0b2b761d30ab&client_secret=cbe46cde-affb-4324-8f26-f69ace80f1ce tests : - status : 200 save : token","title":"A reqman.conf"},{"location":"example/#and-a-yml-test-file","text":"- GET : /api/pets/v1/list tests : - status : 200 save : pets : <<json.items>> - GET : /api/pets/v1/info/<<id>> params : id : <<json.items.0.id>>","title":"And a yml test file"},{"location":"install/","text":"Install On Windows Download reqman.exe On *nix platforms In a console: $ pip3 install reqman (Will install PyYAML , httpcore , stpl and colorama dependencies) From Sources In a console: $ git clone https://github.com/manatlan/reqman.git $ pip3 install pyyaml httpcore stpl colorama $ python3 -m pytest tests/","title":"Installation"},{"location":"install/#install","text":"","title":"Install"},{"location":"install/#on-windows","text":"Download reqman.exe","title":"On Windows"},{"location":"install/#on-nix-platforms","text":"In a console: $ pip3 install reqman (Will install PyYAML , httpcore , stpl and colorama dependencies)","title":"On *nix platforms"},{"location":"install/#from-sources","text":"In a console: $ git clone https://github.com/manatlan/reqman.git $ pip3 install pyyaml httpcore stpl colorama $ python3 -m pytest tests/","title":"From Sources"},{"location":"python/","text":"Python powered Using \"params\" statement, it possible in introduce python scripts, to make you tests more powerful. Can be really useful to: transform data (gzip, base64, encrypt, ...) save content compute complex data ... (You can include all python libs available in reqman, but for others lib you should have python3 on the host with yours libs.) With param value - POST : /post body : <<content>> params : content : | with open(\"image.jpg\",\"rb\") as fid: return fid.read() With method over a param value it's like a param, but 'x' is the input parameter (ENV dict is also available) - POST : /post body : <<content|gzip>> params : content : \"hello world\" gzip : | import zlib return zlib.compress( x ) And you can chain methods like this - POST : /post body : <<content|gzip|b64>> params : content : \"hello world\" gzip : | import zlib return zlib.compress( x ) b65 : | import base64 return base64.b64encode( x ) A better place for theses methods : declare them in the reqman.conf !","title":"Python powered"},{"location":"python/#python-powered","text":"Using \"params\" statement, it possible in introduce python scripts, to make you tests more powerful. Can be really useful to: transform data (gzip, base64, encrypt, ...) save content compute complex data ... (You can include all python libs available in reqman, but for others lib you should have python3 on the host with yours libs.)","title":"Python powered"},{"location":"python/#with-param-value","text":"- POST : /post body : <<content>> params : content : | with open(\"image.jpg\",\"rb\") as fid: return fid.read()","title":"With param value"},{"location":"python/#with-method-over-a-param-value","text":"it's like a param, but 'x' is the input parameter (ENV dict is also available) - POST : /post body : <<content|gzip>> params : content : \"hello world\" gzip : | import zlib return zlib.compress( x ) And you can chain methods like this - POST : /post body : <<content|gzip|b64>> params : content : \"hello world\" gzip : | import zlib return zlib.compress( x ) b65 : | import base64 return base64.b64encode( x ) A better place for theses methods : declare them in the reqman.conf !","title":"With method over a param value"},{"location":"simple_use/","text":"Simplest use Create a yml file (ex: test.yml ) - GET : https://github.com/manatlan/reqman tests : - status : 200 And run it with reqman, in console $ reqman test.yml The console should prints: $ reqman test.yml TEST: test.yml * GET https://github.com/manatlan/reqman --> 200 - OK : status = 200 RESULT: 1/1 (1req(s)) What's happening ? Reqman has requested the url It has tested that HTTP status == 200 it has generated a reqman.html file which contains more details about the http exchange, And it returned a RC code == 0 (no test errors, else will be the number of failed tests, or -1 if error)","title":"Simplest use"},{"location":"simple_use/#simplest-use","text":"Create a yml file (ex: test.yml ) - GET : https://github.com/manatlan/reqman tests : - status : 200 And run it with reqman, in console $ reqman test.yml The console should prints: $ reqman test.yml TEST: test.yml * GET https://github.com/manatlan/reqman --> 200 - OK : status = 200 RESULT: 1/1 (1req(s)) What's happening ? Reqman has requested the url It has tested that HTTP status == 200 it has generated a reqman.html file which contains more details about the http exchange, And it returned a RC code == 0 (no test errors, else will be the number of failed tests, or -1 if error)","title":"Simplest use"},{"location":"yml_syntax/","text":"Reqman language Syntax A reqman's file tests, is a YAML file, endings with \".yml\" or \".rml\" (ReqMan Language). Its content is a list of statements. There are 4 types of statements : A http request A Procedure's declaration A call procedure A break statement A HTTP Request This kind of statement, should contain ONE HTTP VERB, in uppercase (Known HTTP verbs : \"GET\", \"POST\", \"DELETE\", \"PUT\", \"HEAD\", \"OPTIONS\", \"TRACE\", \"PATCH\", \"CONNECT\") - GET : /hello - OPTIONS : /hello - HEAD : /hello And it's generally completed with additionnal keywords A Procedure's declaration This statement declare a procedure which can be only called by a \"call statement\". Here is the declaration of a procedure MyProcedure : - MyProcedure : - GET : /hello1 - GET : /hello2 The content of the procedure is a list which can contains the 4 types of statements. Note : Without a call statement : this file does nothing ... A call procedure This statement let you call a procedure. - call : MyProcedure or - call : - MyProcedure1 - MyProcedure2 And it's generally completed with additionnal keywords A 'break' statement This statement is only useful, when you are working on a test file, it lets you break the process. So you can edit your statements step by step. - GET : /hello1 - break - GET : /hello2 - GET : /hello3 In this case ^^; only the first request is called ... The others are simply ignored. Additionnal keywords Theses keywords can be added on request or call statements, to complete the statement. \"body\" Let you add a 'body' in your POST statements ;-) - POST : /hello body : \"I'm the body\" - POST : /hello body : { \"key\" : 12 , \"value\" : \"hello\" } - POST : /hello body : key : 12 value : \"hello\" Body described in yaml syntax, will automatically converted in json. The latest 2 examples are the same. \"headers\" Let you add 'headers' in yours statements. - POST : /hello body : \"I'm the body\" headers : content-type : text/plain x-hello : it's me If there are global or inherited headers, you can override them, by setting them to null , like that: - myproc : - POST : /hello body : \"I'm the body\" headers : content-type : # leave empty, will not send the content-type from the caller x-hello : it's me - call : myproc headers : content-type : application/json Header's keys are case insensitive. \"tests\" Let you add 'tests' in yours statements. - GET : /returnJson # return {\"result\":{\"content\":\"ok\",\"value\":3.3, \"list\":[42,43]}} tests : - status : 200 - content-type : application/json # test a response header - content : \"result\" # ensure that the global response contains text \"result\" - json.result.content : \"ok\" - json.result.content : . != \"ko\" - json.result.content.size : 2 # test size of the string - json.result.size : 2 # test size of the dict - json.result.value : . > 3 - json.result.value : . <= 4 - json.result.list.0 : 42 # refer to the first item in the list - json.result.list.1 : 43 # refer to the second item in the list - json.result.list.-1 : 43 # refer to the last item in the list \"doc\" - GET : /test doc : \"Just a description which is displayed in the html output for this request on <<root>> !\" Yes, you can use var substitutions in doc ! \"params\" - GET : /<<path>> params : path : \"hello\" <<path>> is substitued by the value of the param path . \"save\" It lets you save parameters for later use. Theses parameters are only available in the current yaml tests. Only thoses saved in the BEGIN procedure will be shared with all test files. Save all the response - GET : /returnJson # return {\"result\":{\"content\":\"ok\",\"value\":3.3}} save : allJson Now, you can use 'allJson' in following statements Save a partial response in a new param 'rcontent' - GET : /returnJson # return {\"result\":{\"content\":\"ok\",\"value\":3.3}} save : rcontent : <<json.result.content>> Now, you can use 'rcontent' in following statements \"foreach\" It let you repeat your statement, with a list of dict. - GET : /test/<<value>> foreach : - value : 1 - value : 2 - value : 3 Will make 3 requests, it the same things as : - GET : /test/1 - GET : /test/2 - GET : /test/3","title":"Test's Grammar"},{"location":"yml_syntax/#reqman-language-syntax","text":"A reqman's file tests, is a YAML file, endings with \".yml\" or \".rml\" (ReqMan Language). Its content is a list of statements. There are 4 types of statements : A http request A Procedure's declaration A call procedure A break statement","title":"Reqman language Syntax"},{"location":"yml_syntax/#a-http-request","text":"This kind of statement, should contain ONE HTTP VERB, in uppercase (Known HTTP verbs : \"GET\", \"POST\", \"DELETE\", \"PUT\", \"HEAD\", \"OPTIONS\", \"TRACE\", \"PATCH\", \"CONNECT\") - GET : /hello - OPTIONS : /hello - HEAD : /hello And it's generally completed with additionnal keywords","title":"A HTTP Request"},{"location":"yml_syntax/#a-procedures-declaration","text":"This statement declare a procedure which can be only called by a \"call statement\". Here is the declaration of a procedure MyProcedure : - MyProcedure : - GET : /hello1 - GET : /hello2 The content of the procedure is a list which can contains the 4 types of statements. Note : Without a call statement : this file does nothing ...","title":"A Procedure's declaration"},{"location":"yml_syntax/#a-call-procedure","text":"This statement let you call a procedure. - call : MyProcedure or - call : - MyProcedure1 - MyProcedure2 And it's generally completed with additionnal keywords","title":"A call procedure"},{"location":"yml_syntax/#a-break-statement","text":"This statement is only useful, when you are working on a test file, it lets you break the process. So you can edit your statements step by step. - GET : /hello1 - break - GET : /hello2 - GET : /hello3 In this case ^^; only the first request is called ... The others are simply ignored.","title":"A 'break' statement"},{"location":"yml_syntax/#additionnal-keywords","text":"Theses keywords can be added on request or call statements, to complete the statement.","title":"Additionnal keywords"},{"location":"yml_syntax/#body","text":"Let you add a 'body' in your POST statements ;-) - POST : /hello body : \"I'm the body\" - POST : /hello body : { \"key\" : 12 , \"value\" : \"hello\" } - POST : /hello body : key : 12 value : \"hello\" Body described in yaml syntax, will automatically converted in json. The latest 2 examples are the same.","title":"\"body\""},{"location":"yml_syntax/#headers","text":"Let you add 'headers' in yours statements. - POST : /hello body : \"I'm the body\" headers : content-type : text/plain x-hello : it's me If there are global or inherited headers, you can override them, by setting them to null , like that: - myproc : - POST : /hello body : \"I'm the body\" headers : content-type : # leave empty, will not send the content-type from the caller x-hello : it's me - call : myproc headers : content-type : application/json Header's keys are case insensitive.","title":"\"headers\""},{"location":"yml_syntax/#tests","text":"Let you add 'tests' in yours statements. - GET : /returnJson # return {\"result\":{\"content\":\"ok\",\"value\":3.3, \"list\":[42,43]}} tests : - status : 200 - content-type : application/json # test a response header - content : \"result\" # ensure that the global response contains text \"result\" - json.result.content : \"ok\" - json.result.content : . != \"ko\" - json.result.content.size : 2 # test size of the string - json.result.size : 2 # test size of the dict - json.result.value : . > 3 - json.result.value : . <= 4 - json.result.list.0 : 42 # refer to the first item in the list - json.result.list.1 : 43 # refer to the second item in the list - json.result.list.-1 : 43 # refer to the last item in the list","title":"\"tests\""},{"location":"yml_syntax/#doc","text":"- GET : /test doc : \"Just a description which is displayed in the html output for this request on <<root>> !\" Yes, you can use var substitutions in doc !","title":"\"doc\""},{"location":"yml_syntax/#params","text":"- GET : /<<path>> params : path : \"hello\" <<path>> is substitued by the value of the param path .","title":"\"params\""},{"location":"yml_syntax/#save","text":"It lets you save parameters for later use. Theses parameters are only available in the current yaml tests. Only thoses saved in the BEGIN procedure will be shared with all test files.","title":"\"save\""},{"location":"yml_syntax/#save-all-the-response","text":"- GET : /returnJson # return {\"result\":{\"content\":\"ok\",\"value\":3.3}} save : allJson Now, you can use 'allJson' in following statements","title":"Save all the response"},{"location":"yml_syntax/#save-a-partial-response-in-a-new-param-rcontent","text":"- GET : /returnJson # return {\"result\":{\"content\":\"ok\",\"value\":3.3}} save : rcontent : <<json.result.content>> Now, you can use 'rcontent' in following statements","title":"Save a partial response in a new param 'rcontent'"},{"location":"yml_syntax/#foreach","text":"It let you repeat your statement, with a list of dict. - GET : /test/<<value>> foreach : - value : 1 - value : 2 - value : 3 Will make 3 requests, it the same things as : - GET : /test/1 - GET : /test/2 - GET : /test/3","title":"\"foreach\""}]}